   1:				.include "constants.asm"
**** constants.asm ****
   1:     -	0000          	TEC_1 EQU 0
   2:     -	0000          	RC2014 EQU 0
   3:     -	0001          	BEANZEE EQU 1
   4:				
   5:     -	0000          	EXTENDED EQU 0
   6:				
   7:     -	0000          	.if RC2014
  16:				.endif
  17:				
  18:     -	0000          	.if TEC_1
  35:				.endif
  36:				
  37:     -	0001          	.if BEANZEE
  38:				
  39:				; Configuration for BeanZee
  40:     -	0000          	ROMSTART    EQU $0000
  41:     -	8000          	RAMSTART    EQU $8000
  42:     -	0000          	LOADER EQU 0
  43:     -	0000          	BITBANG EQU 0
  44:				
  45:				.endif
**** BeanZee.z80 ****
   2:				.include "IOSerial.asm"
**** IOSerial.asm ****
   1:				        ; ROM code
   2:				        ; Targets:
   3:				        ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
   4:				        ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
   5:				        ; Serial: Bit Bang, 6850 ACIA
   6:				        
   7:     -	0000          	 .if  TEC_1
  71:				 .endif
  72:				
  73:     -	0001          	 .if BEANZEE
  74:				
  75:				        ;
  76:				        ; USB registers
  77:				        ;----------------------
  78:     -	0000          	        USB_STATUS      .EQU      $00   ;(read)
  79:     -	0001          	        USB_DATA        .EQU      $01   ;(read/write)
  80:				
  81:				        ;
  82:				        ; status register bits
  83:				        ;---------------------
  84:				        ;TXE    .EQU   0          ;transmit data register empty
  85:				        ;RXF    .EQU   1          ;receive data register full
  86:				        ; Using these with bit operations assembles as NOP ???
  87:				
  88:				 .endif
  89:				
  90:				
  91:				; I/O port addresses
  92:				
  93:     -	0000          	 .if TEC_1
 102:				 .endif
 103:     -	0000          	 .if RC2014
 112:				 .endif
 113:				
 114:				; ASCII codes
 115:     -	001B          	ESC:     .EQU   1BH
 116:     -	000D          	CR:      .EQU   0DH
 117:     -	000A          	LF:      .EQU   0AH
 118:				
 119:     -	0000          	        .ORG ROMSTART
 120:				;reset
 121:     -	0000          	RSTVEC:
 122:    0+10	0000  C39600  	        JP	RESET
 123:				
 124:     -	0003          	rst1:
 125:     -	0008          	    	.ORG	ROMSTART+$08
 126:   10+7	0008  2E01    	    	ld l,1
 127:   17+10	000A  C38B00  	    	jp ISR
 128:				    
 129:     -	000D          	rst2:
 130:     -	0010          	        .ORG ROMSTART+$10
 131:   27+7	0010  2E02    	    	ld l,2
 132:   34+10	0012  C38B00  	    	jp ISR
 133:				
 134:     -	0015          	rst3:
 135:     -	0018          	        .ORG ROMSTART+$18 
 136:   44+7	0018  2E03    	    	ld l,3
 137:   51+10	001A  C38B00  	    	jp ISR
 138:				    
 139:     -	001D          	rst4:
 140:     -	0020          	        .ORG ROMSTART+$20
 141:   61+7	0020  2E04    	    	ld l,4
 142:   68+10	0022  C38B00  	    	jp ISR
 143:				
 144:     -	0025          	rst5:
 145:     -	0028          	    	.ORG ROMSTART+$28
 146:   78+7	0028  2E05    	    	ld l,5
 147:   85+10	002A  C38B00  	    	jp ISR
 148:				
 149:     -	002D          	rst6:
 150:     -	0030          	    	.ORG ROMSTART+$30
 151:   95+7	0030  2E06    	    	ld l,6
 152:  102+10	0032  C38B00  	    	jp ISR
 153:				
 154:				;RST 7 Interrupt
 155:     -	0038          	    	.ORG	ROMSTART+$38
 156:				
 157:     -	0000          	 .if  BITBANG
 161:				 .else 
 162:				
 163:  112+10	0038  C9      	        ret
 164:				
 165:				 .endif
 166:				
 167:     -	0040          	        .ORG    ROMSTART+$40
 168:				
 169:				;hexadecimal to 7 segment display code table
 170:     -	0000          	 .if TEC_1
 177:				 .else ;SC
 178:				
 179:     -	0040          	sevensegment:
 180:     -	0040  3F065B4F	            .DB 3FH,06H,5BH,4FH ;0,1,2,3
 181:     -	0044  666D7D07	            .DB 66H,6DH,7DH,07H ;4,5,6,7
 182:     -	0048  7F6F777C	            .DB 7FH,6FH,77H,7CH ;8,9,A,B
 183:     -	004C  395E7971	            .DB 39H,5EH,79H,71H ;C,D,E,F
 184:				 .endif
 185:				
 186:				
 187:				;---------------
 188:				; BIT TIME DELAY
 189:				;---------------
 190:				;DELAY FOR ONE SERIAL BIT TIME
 191:				;ENTRY : HL = DELAY TIME
 192:				; NO REGISTERS MODIFIED
 193:				;
 194:     -	0050          	PWRUP:   
 195:  122+10	0050  210020  	        LD    hl,$2000
 196:     -	0053          	BITIME:
 197:  132+11	0053  E5      	        PUSH  HL
 198:  143+11	0054  D5      	        PUSH  DE
 199:  154+10	0055  110100  	        LD    DE,0001H
 200:     -	0058          	BITIM1:  
 201:  164+15	0058  ED52    	        SBC   HL,DE
 202:  179+10	005A  D25800  	        JP    NC,BITIM1
 203:  189+10	005D  D1      	        POP   DE
 204:  199+10	005E  E1      	        POP   HL
 205:     -	005F          	IntRet:  
 206:  209+10	005F  C9      	        RET
 207:				
 208:				;RST 8  Non Maskable Interrupt
 209:     -	0066          	        .ORG ROMSTART+$66
 210:				        ; PUSH	HL
 211:				        ; LD	HL,(NMIVEC)
 212:				        ; JP	(HL)
 213:				    	
 214:  219+7	0066  2E08    	    	ld l,8
 215:  226+10	0068  C38B00  	    	jp ISR
 216:				
 217:     -	0000          	 .if  TEC_1
 341:				 .endif
 342:				
 343:     -	0001          	 .if BEANZEE
 344:				;
 345:				; transmit a character in a
 346:				;--------------------------
 347:     -	006B          	TXDATA:
 348:     -	006B          	TxChar:  
 349:  236+11	006B  C5      	        push  bc
 350:  247+4	006C  47      	        ld    b,a                   ;save the character  for later
 351:     -	006D          	TxChar1: 
 352:  251+11	006D  DB00    	        in    a,(USB_STATUS)        ;get the USB status
 353:  262+8	006F  CB47    	        bit   0,a                   ;ready to transmit? (active low)
 354:  270+7+5	0071  20FA    	        jr    nz,TxChar1            ;no, bit is high
 355:  277+4	0073  78      	        ld    a,b                   ;yes, get the character
 356:  281+11	0074  D301    	        out   (USB_DATA),a          ;and send it
 357:  292+10	0076  C1      	        pop   bc
 358:  302+10	0077  C9      	        ret
 359:				;
 360:				; receive  a character in a
 361:				;---------------------------------
 362:     -	0078          	RXDATA:
 363:     -	0078          	RxChar:  
 364:  312+11	0078  DB00    	        in    a,(USB_STATUS)        ;get the USB status
 365:  323+8	007A  CB4F    	        bit   1,a                   ;data to read? (active low)
 366:  331+7+5	007C  20FA    	        jr    nz,RxChar             ;no, the buffer is empty
 367:  338+11	007E  DB01    	        in    a,(USB_DATA)          ;yes, read the received char
 368:  349+10	0080  C9      	        ret
 369:				
 370:				 .endif
 371:				
 372:				
 373:     -	0000          	 .if LOADER
 472:				 .endif
 473:				
 474:				; in this example code just wait for an INTEL Hex file download
 475:				;just going to send a char to let you know I'm here
 476:     -	0000          	 .if LOADER
 486:				 .endif
 487:				
 488:     -	0081          	getchar:
 489:  359+16	0081  2A1882  	        LD HL,(GETCVEC)
 490:  375+4	0084  E9      	        JP (HL)
 491:				
 492:     -	0085          	putchar:
 493:  379+11	0085  E5      	        PUSH HL
 494:  390+16	0086  2A1A82  	        LD HL,(PUTCVEC)
 495:  406+19	0089  E3      	        EX (SP),HL
 496:  425+10	008A  C9      	        RET
 497:				
 498:     -	008B          	ISR:
 499:  435+7	008B  2600    	        ld h,0
 500:  442+16	008D  229284  	    	ld (vIntID),hl
 501:  458+17	0090  CDBD03  	    	call enter
 502:     -	0093  5A00    	    	db "Z",0
 503:  475+10	0095  C9      	    	ret
 504:				
 505:     -	0096          	RESET:   
 506:  485+10	0096  310082  	        ld SP,stack
 507:  495+10	0099  215F00  	        LD HL,IntRet
 508:  505+16	009C  220682  	    	LD (RST08),HL
 509:  521+16	009F  220882  	    	LD (RST10),HL
 510:  537+16	00A2  220A82  	    	LD (RST18),HL
 511:  553+16	00A5  220C82  	    	LD (RST20),HL
 512:  569+16	00A8  220E82  	    	LD (RST28),HL
 513:  585+16	00AB  221082  	    	LD (RST30),HL
 514:  601+16	00AE  221482  	        LD (INTVEC),HL
 515:  617+16	00B1  221682  	        LD (NMIVEC),HL
 516:				
 517:  633+10	00B4  217800  	        LD HL,RXDATA
 518:  643+16	00B7  221882  	        LD (GETCVEC),HL
 519:  659+10	00BA  216B00  	        LD HL,TXDATA
 520:  669+16	00BD  221A82  	        LD (PUTCVEC),HL
 521:				
 522:     -	0000          	 .if TEC_1
 529:				 .endif
 530:				
 531:  685+17	00C0  CD5000  	        call PWRUP
 532:  702+8	00C3  ED56    	        IM  1
 533:  710+4	00C5  FB      	        EI
 534:				
 535:     -	0000          	 .if TEC_1
 551:				 .endif
 552:				        
 553:				
**** BeanZee.z80 ****
   3:				        
   4:				
   5:  714+10	00C6  C31802  	    jp   start              ; into #180 of the prog
   6:				
   7:				.include "MAIN.asm"
**** MAIN.asm ****
   1:				; *************************************************************************
   2:				;
   3:				;       MINT 2.0 Minimal Interpreter for the Z80 
   4:				;
   5:				;       John Hardy and Ken Boak
   6:				;       incorporates bit-bang serial routines by Craig Jones 
   7:				;
   8:				;       GNU GENERAL PUBLIC LICENSE                   Version 3, 29 June 2007
   9:				;
  10:				;       see the LICENSE file in this repo for more information 
  11:				;
  12:				; *****************************************************************************
  13:     -	FFFF          	    TRUE        EQU -1		
  14:     -	0000          	    FALSE       EQU 0
  15:     -	FFFF          	    UNLIMITED   EQU -1		
  16:				
  17:     -	0003          	    CTRL_C      equ 3
  18:     -	0005          	    CTRL_E      equ 5
  19:     -	0008          	    CTRL_H      equ 8
  20:     -	000C          	    CTRL_L      equ 12
  21:     -	0012          	    CTRL_R      equ 18
  22:     -	0013          	    CTRL_S      equ 19
  23:				
  24:     -	005C          	    BSLASH      equ $5c
  25:				
  26:     -	000D          	    ASCII_CR    equ $0d ; \r
  27:     -	000A          	    ASCII_NL    equ $0a ; \n
  28:     -	0008          	    ASCII_BS    equ $08 ; \b
  29:				
  30:				LITDAT .macro len
  31:				    db len
  32:				.endm
  33:				
  34:				REPDAT .macro len,data			; compress the command tables
  35:				    
  36:				    db (len | $80)
  37:				    db data
  38:				.endm
  39:				
  40:				ENDDAT .macro
  41:				    db 0
  42:				.endm
  43:				
  44:				; **************************************************************************
  45:				; Page 0  Initialisation
  46:				; **************************************************************************		
  47:				
  48:     -	0180          		.ORG ROMSTART + $180		; 0+180 put mint code from here	
  49:				
  50:				; **************************************************************************
  51:				; Macros must be written in Mint and end with ; 
  52:				; this code must not span pages
  53:				; **************************************************************************
  54:     -	0180          	macros:
  55:				
  56:     -	0180          	reedit_:
  57:     -	0180  2F7A2F5A	    db "/z/Z;"			; remembers last line edited
	              3B
  58:				
  59:     -	0185          	edit_:
  60:     -	0185  603F602F	    db "`?`/K/P/Z;",0
	              4B2F502F
	              5A3B00
  61:				
  62:     -	0190          	list_:
  63:     -	0190  2F4E3236	    db "/N26(/i65+/Z/k0>(/N))/P;",0
	              282F6936
	              352B2F5A
	              2F6B303E
	              282F4E29
	              292F503B
	              00
  64:				
  65:     -	01A9          	printStack_:
  66:     -	01A9  603D3E20	    db "`=> `/s2- /D1-(",$22,",2-)'/N/P;",0        
	              602F7332
	              2D202F44
	              312D2822
	              2C322D29
	              272F4E2F
	              503B00
  67:				
  68:     -	01C4          	iOpcodes:
  69:     -	01C4  0F      	    LITDAT 15
  70:     -	01C5  1D      	    db    low(bang_)        ;   !            
  71:     -	01C6  71      	    db    low(dquote_)      ;   "
  72:     -	01C7  EE      	    db    low(hash_)        ;   #
  73:     -	01C8  92      	    db    low(dollar_)      ;   $            
  74:     -	01C9  79      	    db    low(percent_)     ;   %            
  75:     -	01CA  2D      	    db    low(amper_)       ;   &
  76:     -	01CB  00      	    db    low(quote_)       ;   '
  77:     -	01CC  E9      	    db    low(lparen_)      ;   (        
  78:     -	01CD  E0      	    db    low(rparen_)      ;   )
  79:     -	01CE  F0      	    db    low(star_)        ;   *            
  80:     -	01CF  4F      	    db    low(plus_)        ;   +
  81:     -	01D0  6B      	    db    low(comma_)       ;   ,            
  82:     -	01D1  96      	    db    low(minus_)       ;   -
  83:     -	01D2  60      	    db    low(dot_)         ;   .
  84:     -	01D3  F2      	    db    low(slash_)       ;   /	
  85:				
  86:     -	01D4  8ADD    	    REPDAT 10, low(num_)	; 10 x repeat lsb of add to the num routine 
  87:				
  88:     -	01D6  07      	    LITDAT 7
  89:     -	01D7  E6      	    db    low(colon_)       ;    :        
  90:     -	01D8  80      	    db    low(semi_)        ;    ;
  91:     -	01D9  BA      	    db    low(lt_)          ;    <
  92:     -	01DA  AB      	    db    low(eq_)          ;    =            
  93:     -	01DB  B6      	    db    low(gt_)          ;    >            
  94:     -	01DC  EC      	    db    low(question_)    ;    ?   
  95:     -	01DD  01      	    db    low(at_)          ;    @    
  96:				
  97:     -	01DE  9A56    	    REPDAT 26, low(call_)	; call a command a, B ....Z
  98:				
  99:     -	01E0  06      	    LITDAT 6
 100:     -	01E1  D4      	    db    low(lbrack_)      ;    [
 101:     -	01E2  03      	    db    low(bslash_)      ;    \
 102:     -	01E3  E3      	    db    low(rbrack_)      ;    ]
 103:     -	01E4  41      	    db    low(caret_)       ;    ^
 104:     -	01E5  01      	    db    low(underscore_)  ;    _   
 105:     -	01E6  C5      	    db    low(grave_)       ;    `   ; for printing `hello`        
 106:				
 107:     -	01E7  9A05    	    REPDAT 26, low(var_)	; a b c .....z
 108:				
 109:     -	01E9  04      	    LITDAT 4
 110:     -	01EA  87      	    db    low(lbrace_)      ;    {
 111:     -	01EB  38      	    db    low(pipe_)        ;    |            
 112:     -	01EC  8B      	    db    low(rbrace_)      ;    }            
 113:     -	01ED  4A      	    db    low(tilde_)       ;    ~ ( a b c -- b c a ) rotate            
 114:				
 115:     -	01EE          	iAltCodes:
 116:				
 117:     -	01EE  1A      	    LITDAT 26
 118:     -	01EF  00      	    db     low(alloc_)      ;A      allocate some heap memory
 119:     -	01F0  09      	    db     low(aNop_)       ;B        
 120:     -	01F1  34      	    db     low(printChar_)  ;C      print a char
 121:     -	01F2  23      	    db     low(depth_)      ;D      depth of stack
 122:     -	01F3  3B      	    db     low(else_)       ;E      else
 123:     -	01F4  31      	    db     low(falsex_)     ;F      false condition
 124:     -	01F5  53      	    db     low(go_)         ;G      go execute mint code
 125:     -	01F6  09      	    db     low(aNop_)       ;H
 126:     -	01F7  70      	    db     low(inPort_)     ;I      input from port
 127:     -	01F8  09      	    db     low(aNop_)       ;J
 128:     -	01F9  68      	    db     low(key_)        ;K      read a char from input
 129:     -	01FA  09      	    db     low(aNop_)       ;L      
 130:     -	01FB  09      	    db     low(aNop_)       ;M
 131:     -	01FC  7A      	    db     low(newln_)      ;N      prints a newline to output
 132:     -	01FD  7F      	    db     low(outPort_)    ;O      output to port
 133:     -	01FE  4E      	    db     low(prompt_)     ;P      print MINT prompt
 134:     -	01FF  09      	    db     low(aNop_)       ;Q
 135:     -	0200  09      	    db     low(aNop_)       ;R
 136:     -	0201  0B      	    db     low(arrSize_)    ;S      array size
 137:     -	0202  88      	    db     low(truex_)      ;T      true condition
 138:     -	0203  8B      	    db     low(unlimit_)    ;U      unlimited loop
 139:     -	0204  90      	    db     low(varAccess_)  ;V      address of last access
 140:     -	0205  13      	    db     low(while_)      ;W      conditional break from loop
 141:     -	0206  41      	    db     low(exec_)       ;X      execute machine code 
 142:     -	0207  09      	    db     low(aNop_)       ;Y
 143:     -	0208  49      	    db     low(editDef_)    ;Z      edit line
 144:     -	0209  00      	    ENDDAT 
 145:				
 146:     -	020A          	backSpace:
 147:  724+4	020A  79      	    ld a,c
 148:  728+4	020B  B0      	    or b
 149:  732+7+5	020C  2827    	    jr z, interpret2
 150:  739+6	020E  0B      	    dec bc
 151:  745+17	020F  CD9203  	    call printStr
 152:     -	0212  08200800	    db ASCII_BS," ",ASCII_BS,0
 153:  762+12	0216  181D    	    jr interpret2
 154:				    
 155:     -	0218          	start:
 156:  774+10	0218  310082  	    ld SP,DSTACK		; start of MINT
 157:  784+17	021B  CDDE02  	    call init		    ; setups
 158:  801+17	021E  CD9203  	    call printStr		; prog count to stack, put code line 235 on stack then call print
 159:     -	0221  4D494E54	    db "MINT2.0",ASCII_CR,ASCII_NL,0
	              322E300D
	              0A00
 160:				
 161:     -	022B          	interpret:
 162:  818+17	022B  CD8203  	    call prompt
 163:				
 164:  835+10	022E  010000  	    ld bc,0                 ; load bc with offset into TIB, decide char into tib or execute or control         
 165:  845+20	0231  ED437C84	    ld (vTIBPtr),bc
 166:				
 167:     -	0235          	interpret2:                     ; calc nesting (a macro might have changed it)
 168:  865+7	0235  1E00    	    ld E,0                  ; initilize nesting value
 169:  872+11	0237  C5      	    push bc                 ; save offset into TIB, 
 170:				                            ; bc is also the count of chars in TIB
 171:  883+10	0238  210080  	    ld hl,TIB               ; hl is start of TIB
 172:  893+12	023B  1806    	    jr interpret4
 173:				
 174:     -	023D          	interpret3:
 175:  905+7	023D  7E      	    ld a,(hl)               ; A = char in TIB
 176:  912+6	023E  23      	    inc hl                  ; inc pointer into TIB
 177:  918+6	023F  0B      	    dec bc                  ; dec count of chars in TIB
 178:  924+17	0240  CD5B03  	    call nesting            ; update nesting value
 179:				
 180:     -	0243          	interpret4:
 181:  941+4	0243  79      	    ld a,C                  ; is count zero?
 182:  945+4	0244  B0      	    or B
 183:  949+7+5	0245  20F6    	    jr NZ, interpret3       ; if not loop
 184:  956+10	0247  C1      	    pop bc                  ; restore offset into TIB
 185:				
 186:     -	0248          	waitchar:   
 187:  966+17	0248  CD8100  	    call getchar            ; loop around waiting for character from serial port
 188:  983+7	024B  FE20    	    cp $20			; compare to space
 189:  990+7+5	024D  3039    	    jr NC,waitchar1		; if >= space, if below 20 set cary flag
 190:  997+7	024F  FE00    	    cp $0                   ; is it end of string? null end of string
 191: 1004+7+5	0251  2859    	    jr Z,waitchar4
 192: 1011+7	0253  FE0D    	    cp ASCII_CR                 ; carriage return? ascii 13
 193: 1018+7+5	0255  283F    	    jr Z,waitchar3		; if anything else its macro/control 
 194: 1025+7	0257  FE08    	    cp CTRL_H
 195: 1032+7+5	0259  28AF    	    jr z,backSpace
 196: 1039+7	025B  1601    	    ld d,high(macros)
 197: 1046+7	025D  FE05    	    cp CTRL_E
 198: 1053+7	025F  1E85    	    ld e,low(edit_)
 199: 1060+7+5	0261  2814    	    jr z,macro
 200: 1067+7	0263  FE12    	    cp CTRL_R
 201: 1074+7	0265  1E80    	    ld e,low(reedit_)
 202: 1081+7+5	0267  280E    	    jr z,macro
 203: 1088+7	0269  FE0C    	    cp CTRL_L
 204: 1095+7	026B  1E90    	    ld e,low(list_)
 205: 1102+7+5	026D  2808    	    jr z,macro
 206: 1109+7	026F  FE13    	    cp CTRL_S
 207: 1116+7	0271  1EA9    	    ld e,low(printStack_)
 208: 1123+7+5	0273  2802    	    jr z,macro
 209: 1130+12	0275  18BE    	    jr interpret2
 210:				
 211:     -	0277          	macro:                          
 212: 1142+20	0277  ED437C84	    ld (vTIBPtr),bc
 213: 1162+11	027B  D5      	    push de
 214: 1173+17	027C  CDBD03  	    call ENTER		;mint go operation and jump to it
 215:     -	027F  2F4700  	    db "/G",0
 216: 1190+20	0282  ED4B7C84	    ld bc,(vTIBPtr)
 217: 1210+12	0286  18AD    	    jr interpret2
 218:				
 219:     -	0288          	waitchar1:
 220: 1222+10	0288  210080  	    ld hl,TIB
 221: 1232+11	028B  09      	    add hl,bc
 222: 1243+7	028C  77      	    ld (hl),A               ; store the character in textbuf
 223: 1250+6	028D  03      	    inc bc
 224: 1256+17	028E  CD8500  	    call putchar            ; echo character to screen
 225: 1273+17	0291  CD5B03  	    call nesting
 226: 1290+12	0294  18B2    	    jr  waitchar            ; wait for next character
 227:				
 228:     -	0296          	waitchar3:
 229: 1302+10	0296  210080  	    ld hl,TIB
 230: 1312+11	0299  09      	    add hl,bc
 231: 1323+10	029A  360D    	    ld (hl),ASCII_CR            ; store the crlf in textbuf
 232: 1333+6	029C  23      	    inc hl
 233: 1339+10	029D  360A    	    ld (hl),ASCII_NL            
 234: 1349+6	029F  23      	    inc hl                  ; ????
 235: 1355+6	02A0  03      	    inc bc
 236: 1361+6	02A1  03      	    inc bc
 237: 1367+17	02A2  CD8B03  	    call crlf               ; echo character to screen
 238: 1384+4	02A5  7B      	    ld a,E                  ; if zero nesting append and ETX after \r
 239: 1388+4	02A6  B7      	    or A
 240: 1392+7+5	02A7  209F    	    jr NZ,waitchar
 241: 1399+10	02A9  3603    	    ld (hl),$03             ; store end of text ETX in text buffer 
 242: 1409+6	02AB  03      	    inc bc
 243:				
 244:     -	02AC          	waitchar4:    
 245: 1415+20	02AC  ED437C84	    ld (vTIBPtr),bc
 246: 1435+10	02B0  010080  	    ld bc,TIB               ; Instructions stored on heap at address HERE, we pressed enter
 247: 1445+6	02B3  0B      	    dec bc
 248:				
 249:     -	02B4          	NEXT:                           
 250: 1451+6	02B4  03      	    inc bc                      ; Increment the IP
 251: 1457+7	02B5  0A      	    ld a,(bc)                   ; Get the next character and dispatch
 252: 1464+4	02B6  B7      	    or a                        ; is it NUL?       
 253: 1468+7+5	02B7  280F    	    jr z,exit
 254: 1475+7	02B9  FE03    	    cp CTRL_C
 255: 1482+7+5	02BB  2815    	    jr z,etx
 256: 1489+7	02BD  D621    	    sub "!"
 257: 1496+7+5	02BF  38F3    	    jr c,NEXT
 258: 1503+4	02C1  6F      	    ld L,A                      ; Index into table
 259: 1507+7	02C2  2683    	    ld H,high(opcodes)           ; Start address of jump table         
 260: 1514+7	02C4  6E      	    ld L,(hl)                   ; get low jump address
 261: 1521+7	02C5  2604    	    ld H,high(page4)             ; Load H with the 1st page address
 262: 1528+4	02C7  E9      	    jp (hl)                     ; Jump to routine
 263:				
 264:     -	02C8          	exit:
 265: 1532+6	02C8  03      	    inc bc			; store offests into a table of bytes, smaller
 266: 1538+4	02C9  50      	    ld d,b
 267: 1542+4	02CA  59      	    ld e,c                
 268: 1546+17	02CB  CDAD03  	    call rpop               ; Restore Instruction pointer
 269: 1563+4	02CE  44      	    ld b,h
 270: 1567+4	02CF  4D      	    ld c,l
 271: 1571+4	02D0  EB      	    EX de,hl
 272: 1575+4	02D1  E9      	    jp (hl)
 273:				
 274:     -	02D2          	etx:                                
 275: 1579+10	02D2  21007E  	    ld hl,$7e00               ; -DSTACK ; check if stack pointer is underwater
 276: 1589+11	02D5  39      	    add hl,SP
 277: 1600+7+5	02D6  3003    	    jr NC,etx1
 278: 1607+10	02D8  310082  	    ld SP,DSTACK
 279:     -	02DB          	etx1:
 280: 1617+10	02DB  C32B02  	    jp interpret
 281:				
 282:     -	02DE          	init:                           
 283: 1627+14	02DE  DD218081	    ld IX,RSTACK
 284: 1641+14	02E2  FD21B402	    ld IY,NEXT		; IY provides a faster jump to NEXT
 285:				
 286: 1655+10	02E6  210084  	    ld hl,vars              
 287: 1665+4	02E9  54      	    ld d,h
 288: 1669+4	02EA  5D      	    ld e,l
 289: 1673+6	02EB  13      	    inc de
 290: 1679+10	02EC  3600    	    ld (hl),0
 291: 1689+10	02EE  019C00  	    ld bc,VARS_SIZE * 3         ; init vars, defs and altVars
 292: 1699+16+5	02F1  EDB0    	    LDIR
 293:				
 294: 1715+10	02F3  210082  	    ld hl,dStack
 295: 1725+16	02F6  228C84  	    ld (vStkStart),hl
 296: 1741+10	02F9  214100  	    ld hl,65
 297: 1751+16	02FC  229A84  	    ld (vLastDef),hl
 298: 1767+10	02FF  21A084  	    ld hl,HEAP
 299: 1777+16	0302  227684  	    ld (vHeapPtr),hl
 300:				
 301:     -	0305          	initOps:
 302: 1793+10	0305  21C401  	    ld hl, iOpcodes
 303: 1803+10	0308  110083  	    ld de, opcodes
 304: 1813+10	030B  017800  	    ld bc, $80-32-1-1+26
 305:				
 306:     -	030E          	initOps1:
 307: 1823+7	030E  7E      	    ld a,(hl)
 308: 1830+6	030F  23      	    inc hl
 309: 1836+8	0310  CB27    	    SLA A                     
 310: 1844+5+6	0312  C8      	    ret Z
 311: 1849+7+5	0313  3809    	    jr C, initOps2
 312: 1856+8	0315  CB3F    	    SRL A
 313: 1864+4	0317  4F      	    ld C,A
 314: 1868+7	0318  0600    	    ld B,0
 315: 1875+16+5	031A  EDB0    	    LDIR
 316: 1891+12	031C  18F0    	    jr initOps1
 317:				    
 318:     -	031E          	initOps2:        
 319: 1903+8	031E  CB3F    	    SRL A
 320: 1911+4	0320  47      	    ld B,A
 321: 1915+7	0321  7E      	    ld a,(hl)
 322: 1922+6	0322  23      	    inc hl
 323:     -	0323          	initOps2a:
 324: 1928+7	0323  12      	    ld (de),A
 325: 1935+6	0324  13      	    inc de
 326: 1941+8+5	0325  10FC    	    DJNZ initOps2a
 327: 1949+12	0327  18E5    	    jr initOps1
 328:				
 329:     -	0329          	lookupRef0:
 330: 1961+10	0329  213484  	    ld hl,defs
 331: 1971+7	032C  D641    	    sub "A"
 332: 1978+12	032E  1802    	    jr lookupRef1        
 333:     -	0330          	lookupRef:
 334: 1990+7	0330  D661    	    sub "a"
 335:     -	0332          	lookupRef1:
 336: 1997+4	0332  87      	    add a,a
 337: 2001+4	0333  85      	    add a,l
 338: 2005+4	0334  6F      	    ld l,a
 339: 2009+7	0335  3E00    	    ld a,0
 340: 2016+4	0337  8C      	    ADC a,h
 341: 2020+4	0338  67      	    ld h,a
 342: 2024+4	0339  AF      	    XOR a
 343: 2028+4	033A  B3      	    or e                        ; sets Z flag if A-Z
 344: 2032+10	033B  C9      	    ret
 345:				
 346:     -	033C          	printhex:                           
 347:				                                ; Display hl as a 16-bit number in hex.
 348: 2042+11	033C  C5      	    push bc                     ; preserve the IP
 349: 2053+4	033D  7C      	    ld a,H
 350: 2057+17	033E  CD4703  	    call printhex2
 351: 2074+4	0341  7D      	    ld a,L
 352: 2078+17	0342  CD4703  	    call printhex2
 353: 2095+10	0345  C1      	    pop bc
 354: 2105+10	0346  C9      	    ret
 355:     -	0347          	printhex2:		                    
 356: 2115+4	0347  4F      	    ld	C,A
 357: 2119+4	0348  1F      		RRA 
 358: 2123+4	0349  1F      		RRA 
 359: 2127+4	034A  1F      		RRA 
 360: 2131+4	034B  1F      		RRA 
 361: 2135+17	034C  CD5003  	    call printhex3
 362: 2152+4	034F  79      	    ld a,C
 363:     -	0350          	printhex3:		
 364: 2156+7	0350  E60F    	    and	0x0F
 365: 2163+7	0352  C690    		add	a,0x90
 366: 2170+4	0354  27      		DAA
 367: 2174+7	0355  CE40    		ADC	a,0x40
 368: 2181+4	0357  27      		DAA
 369: 2185+10	0358  C38500  		jp putchar
 370:				
 371:				; **************************************************************************             
 372:				; calculate nesting value
 373:				; A is char to be tested, 
 374:				; E is the nesting value (initially 0)
 375:				; E is increased by ( and [ 
 376:				; E is decreased by ) and ]
 377:				; E has its bit 7 toggled by `
 378:				; limited to 127 levels
 379:				; **************************************************************************             
 380:				
 381:     -	035B          	nesting:                        
 382: 2195+7	035B  FE60    	    cp '`'
 383: 2202+7+5	035D  2005    	    jr NZ,nesting1
 384: 2209+7	035F  3E80    	    ld a,$80
 385: 2216+4	0361  AB      	    xor e
 386: 2220+4	0362  5F      	    ld e,a
 387: 2224+10	0363  C9      	    ret
 388:     -	0364          	nesting1:
 389: 2234+8	0364  CB7B    	    BIT 7,E             
 390: 2242+5+6	0366  C0      	    ret NZ             
 391: 2247+7	0367  FE3A    	    cp ':'
 392: 2254+7+5	0369  2808    	    jr Z,nesting2
 393: 2261+7	036B  FE5B    	    cp '['
 394: 2268+7+5	036D  2804    	    jr Z,nesting2
 395: 2275+7	036F  FE28    	    cp '('
 396: 2282+7+5	0371  2002    	    jr NZ,nesting3
 397:     -	0373          	nesting2:
 398: 2289+4	0373  1C      	    inc E
 399: 2293+10	0374  C9      	    ret
 400:     -	0375          	nesting3:
 401: 2303+7	0375  FE3B    	    cp ';'
 402: 2310+7+5	0377  2807    	    jr Z,nesting4
 403: 2317+7	0379  FE5D    	    cp ']'
 404: 2324+7+5	037B  2803    	    jr Z,nesting4
 405: 2331+7	037D  FE29    	    cp ')'
 406: 2338+5+6	037F  C0      	    ret NZ
 407:     -	0380          	nesting4:
 408: 2343+4	0380  1D      	    dec E
 409: 2347+10	0381  C9      	    ret 
 410:				
 411:     -	0382          	prompt:                            
 412: 2357+17	0382  CD9203  	    call printStr
 413:     -	0385  0D0A3E20	    db ASCII_CR,ASCII_NL,"> ",0
	              00
 414: 2374+10	038A  C9      	    ret
 415:				
 416:     -	038B          	crlf:                               
 417: 2384+17	038B  CD9203  	    call printStr
 418:     -	038E  0D0A00  	    db ASCII_CR,ASCII_NL,0
 419: 2401+10	0391  C9      	    ret
 420:				
 421:     -	0392          	printStr:                           
 422: 2411+19	0392  E3      	    EX (SP),hl		                ; swap			
 423: 2430+17	0393  CD9D03  	    call putStr		
 424: 2447+6	0396  23      	    inc hl			                ; inc past null
 425: 2453+19	0397  E3      	    EX (SP),hl		                ; put it back	
 426: 2472+10	0398  C9      	    ret
 427:				
 428:     -	0399          	putStr0:                            
 429: 2482+17	0399  CD8500  	    call putchar
 430: 2499+6	039C  23      	    inc hl
 431:     -	039D          	putStr:
 432: 2505+7	039D  7E      	    ld a,(hl)
 433: 2512+4	039E  B7      	    or A
 434: 2516+7+5	039F  20F8    	    jr NZ,putStr0
 435: 2523+10	03A1  C9      	    ret
 436:				
 437:     -	03A2          	rpush:                              
 438: 2533+10	03A2  DD2B    	    dec IX                  
 439: 2543+19	03A4  DD7400  	    ld (IX+0),H
 440: 2562+10	03A7  DD2B    	    dec IX
 441: 2572+19	03A9  DD7500  	    ld (IX+0),L
 442: 2591+10	03AC  C9      	    ret
 443:				
 444:     -	03AD          	rpop:                               
 445: 2601+19	03AD  DD6E00  	    ld L,(IX+0)         
 446: 2620+10	03B0  DD23    	    inc IX              
 447: 2630+19	03B2  DD6600  	    ld H,(IX+0)
 448: 2649+10	03B5  DD23    	    inc IX                  
 449:     -	03B7          	rpop2:
 450: 2659+10	03B7  C9      	    ret
 451:				
 452:     -	03B8          	writeChar:                          
 453: 2669+7	03B8  77      	    ld (hl),A
 454: 2676+6	03B9  23      	    inc hl
 455: 2682+10	03BA  C38500  	    jp putchar
 456:				
 457:     -	03BD          	enter:                              
 458: 2692+4	03BD  60      	    ld h,b
 459: 2696+4	03BE  69      	    ld l,c
 460: 2700+17	03BF  CDA203  	    call rpush                      ; save Instruction Pointer
 461: 2717+10	03C2  C1      	    pop bc
 462: 2727+6	03C3  0B      	    dec bc
 463: 2733+8	03C4  FDE9    	    jp (iy)                    
 464:				
 465:     -	03C6          	carry:                              
 466: 2741+10	03C6  210000  	    ld hl,0
 467: 2751+8	03C9  CB15    	    rl l
 468: 2759+16	03CB  226C84  	    ld (vCarry),hl
 469: 2775+8	03CE  FDE9    	    jp (iy)              
 470:				
 471:     -	03D0          	setByteMode:
 472: 2783+7	03D0  3EFF    	    ld a,$FF
 473: 2790+12	03D2  1801    	    jr assignByteMode
 474:     -	03D4          	resetByteMode:
 475: 2802+4	03D4  AF      	    xor a
 476:     -	03D5          	assignByteMode:
 477: 2806+13	03D5  326A84  	    ld (vByteMode),a
 478: 2819+13	03D8  326B84  	    ld (vByteMode+1),a
 479: 2832+8	03DB  FDE9    	    jp (iy)
 480:				
 481:     -	03DD          	false_:
 482: 2840+10	03DD  210000  	    ld hl,FALSE
 483: 2850+12	03E0  1803    	    jr true1
 484:				
 485:     -	03E2          	true_:
 486: 2862+10	03E2  21FFFF  	    ld hl,TRUE
 487:     -	03E5          	true1:
 488: 2872+11	03E5  E5      	    push hl
 489: 2883+8	03E6  FDE9    	    jp (iy)
 490:				
 491:				; **********************************************************************			 
 492:				; Page 4 primitive routines 
 493:				; **********************************************************************
 494:     -	0400          	    org $400 ; .align $100
 495:     -	0400          	page4:
 496:				
 497:     -	0400          	quote_:                          ; Discard the top member of the stack
 498: 2891+10	0400  E1      	    pop     hl
 499:     -	0401          	at_:
 500:     -	0401          	underscore_: 
 501: 2901+8	0401  FDE9    	    jp (iy)
 502:				
 503:     -	0403          	bslash_:
 504: 2909+12	0403  18CB    	    jr setByteMode
 505:				
 506:     -	0405          	var_:
 507: 2921+7	0405  0A      	    ld a,(bc)
 508: 2928+10	0406  210084  	    ld hl,vars
 509: 2938+17	0409  CD3003  	    call lookupRef
 510:     -	040C          	var1:
 511: 2955+16	040C  229C84  	    ld (vPointer),hl
 512: 2971+7	040F  1600    	    ld d,0
 513: 2978+7	0411  5E      	    ld e,(hl)
 514: 2985+13	0412  3A6A84  	    ld a,(vByteMode)                   
 515: 2998+4	0415  3C      	    inc a                       ; is it byte?
 516: 3002+7+5	0416  2802    	    jr z,var2
 517: 3009+6	0418  23      	    inc hl
 518: 3015+7	0419  56      	    ld d,(hl)
 519:     -	041A          	var2:
 520: 3022+11	041A  D5      	    push de
 521: 3033+12	041B  18B7    	    jr resetByteMode
 522:				
 523:     -	041D          	bang_:                      ; Store the value at the address placed on the top of the stack
 524:     -	041D          	assign:
 525: 3045+10	041D  E1      	    pop hl                  ; discard value of last accessed variable
 526: 3055+10	041E  D1      	    pop de                  ; new value
 527: 3065+16	041F  2A9C84  	    ld hl,(vPointer)
 528: 3081+7	0422  73      	    ld (hl),e          
 529: 3088+13	0423  3A6A84  	    ld a,(vByteMode)                   
 530: 3101+4	0426  3C      	    inc a                   ; is it byte?
 531: 3105+7+5	0427  2802    	    jr z,assign1
 532: 3112+6	0429  23      	    inc hl              
 533: 3118+7	042A  72      	    ld (hl),d          
 534:     -	042B          	assign1:
 535: 3125+12	042B  18A7    	    jr resetByteMode
 536:				
 537:     -	042D          	amper_:        
 538: 3137+10	042D  D1      	    pop de                  ;     Bitwise and the top 2 elements of the stack
 539: 3147+10	042E  E1      	    pop hl          
 540: 3157+4	042F  7B      	    ld a,E         
 541: 3161+4	0430  A5      	    and L           
 542: 3165+4	0431  6F      	    ld L,A         
 543: 3169+4	0432  7A      	    ld a,D         
 544: 3173+4	0433  A4      	    and H           
 545:     -	0434          	and1:
 546: 3177+4	0434  67      	    ld h,a         
 547:     -	0435          	and2:
 548: 3181+11	0435  E5      	    push hl          
 549: 3192+8	0436  FDE9    	    jp (iy)           
 550:				
 551:     -	0438          	pipe_: 		 
 552: 3200+10	0438  D1      	    pop de                  ; Bitwise or the top 2 elements of the stack
 553: 3210+10	0439  E1      	    pop hl
 554: 3220+4	043A  7B      	    ld a,E
 555: 3224+4	043B  B5      	    or L
 556: 3228+4	043C  6F      	    ld L,A
 557: 3232+4	043D  7A      	    ld a,D
 558: 3236+4	043E  B4      	    or h
 559: 3240+12	043F  18F3    	    jr and1
 560:				
 561:     -	0441          	caret_:		 
 562: 3252+10	0441  D1      	    pop     de              ; Bitwise XOR the top 2 elements of the stack
 563:     -	0442          	xor1:
 564: 3262+10	0442  E1      	    pop     hl
 565: 3272+4	0443  7B      	    ld      a,E
 566: 3276+4	0444  AD      	    XOR     L
 567: 3280+4	0445  6F      	    ld      L,A
 568: 3284+4	0446  7A      	    ld      a,D
 569: 3288+4	0447  AC      	    XOR     H
 570: 3292+12	0448  18EA    	    jr and1
 571:				
 572:     -	044A          	tilde_:                               
 573:     -	044A          	invert:				        ; Bitwise INVert the top member of the stack
 574: 3304+10	044A  11FFFF  	    ld de, $FFFF            ; by xoring with $FFFF
 575: 3314+12	044D  18F3    	    jr xor1        
 576:				
 577:     -	044F          	plus_:                           ; add the top 2 members of the stack
 578: 3326+10	044F  D1      	    pop     de                 
 579: 3336+10	0450  E1      	    pop     hl                 
 580: 3346+11	0451  19      	    add     hl,de              
 581: 3357+11	0452  E5      	    push    hl                 
 582: 3368+10	0453  C3C603  	    jp carry              
 583:				                             
 584:     -	0456          	call_:
 585: 3378+7	0456  0A      	    ld a,(bc)
 586: 3385+17	0457  CD2903  	    call lookupRef0
 587: 3402+7	045A  5E      	    ld E,(hl)
 588: 3409+6	045B  23      	    inc hl
 589: 3415+7	045C  56      	    ld D,(hl)
 590: 3422+10	045D  C35406  	    jp go1
 591:				
 592:     -	0460          	dot_:       
 593: 3432+10	0460  E1      	    pop hl
 594: 3442+17	0461  CDC906  	    call printDec
 595:     -	0464          	dot2:
 596: 3459+7	0464  3E20    	    ld a,' '           
 597: 3466+17	0466  CD8500  	    call putChar
 598: 3483+8	0469  FDE9    	    jp (iy)
 599:				
 600:     -	046B          	comma_:                          ; print hexadecimal
 601: 3491+10	046B  E1      	    pop     hl
 602: 3501+17	046C  CD3C03  	    call printhex
 603: 3518+12	046F  18F3    	    jr   dot2
 604:				
 605:     -	0471          	dquote_:        
 606: 3530+10	0471  E1      	    pop     hl              ; Duplicate the top member of the stack
 607: 3540+11	0472  E5      	    push    hl
 608: 3551+11	0473  E5      	    push    hl
 609: 3562+8	0474  FDE9    	    jp (iy)
 610:				
 611: 3570+10	0476  C3B402  	    jp NEXT             ; hardwire white space to always go to NEXT (important for arrays)
 612:				
 613:     -	0479          	percent_:  
 614: 3580+10	0479  E1      	    pop hl              ; Duplicate 2nd element of the stack
 615: 3590+10	047A  D1      	    pop de
 616: 3600+11	047B  D5      	    push de
 617: 3611+11	047C  E5      	    push hl
 618: 3622+11	047D  D5      	    push de              ; and push it to top of stack
 619: 3633+8	047E  FDE9    	    jp (iy)        
 620:				
 621:     -	0480          	semi_:
 622: 3641+17	0480  CDAD03  	    call rpop               ; Restore Instruction pointer
 623: 3658+4	0483  44      	    ld b,h                
 624: 3662+4	0484  4D      	    ld c,l                
 625: 3666+8	0485  FDE9    	    jp (iy)             
 626:				
 627:				;  Left shift { is multiply by 2		
 628:     -	0487          	lbrace_:   
 629: 3674+10	0487  E1      	    pop hl                  ; Duplicate the top member of the stack
 630: 3684+11	0488  29      	    add hl,hl
 631: 3695+12	0489  18AA    	    jr and2                 ; shift left fallthrough into plus_     
 632:				
 633:							;  Right shift } is a divide by 2		
 634:     -	048B          	rbrace_:    
 635: 3707+10	048B  E1      	    pop hl                  ; Get the top member of the stack
 636:     -	048C          	shr1:
 637: 3717+8	048C  CB3C    	    SRL H
 638: 3725+8	048E  CB1D    	    RR L
 639: 3733+12	0490  18A3    	    jr and2
 640:				
 641:				; $ swap                    ; a b -- b a Swap the top 2 elements of the stack
 642:     -	0492          	dollar_:        
 643: 3745+10	0492  E1      	    pop hl
 644: 3755+19	0493  E3      	    EX (SP),hl
 645: 3774+12	0494  189F    	    jr and2
 646:				    
 647:     -	0496          	minus_:       		        ; Subtract the value 2nd on stack from top of stack 
 648: 3786+6	0496  03      	    inc bc                  ; check if sign of a number
 649: 3792+7	0497  0A      	    ld a,(bc)
 650: 3799+6	0498  0B      	    dec bc
 651: 3805+7	0499  FE30    	    cp "0"
 652: 3812+7+5	049B  3805    	    jr c,sub1
 653: 3819+7	049D  FE3A    	    cp "9"+1
 654: 3826+10	049F  DA3E07  	    jp c,num    
 655:     -	04A2          	sub1:
 656: 3836+10	04A2  D1      	    pop de                  
 657: 3846+10	04A3  E1      	    pop hl                  
 658:     -	04A4          	sub2:   
 659: 3856+4	04A4  A7      	    and A                   
 660: 3860+15	04A5  ED52    	    sbc hl,de            
 661: 3875+11	04A7  E5      	    push hl                 
 662: 3886+10	04A8  C3C603  	    jp carry               
 663:				                              
 664:     -	04AB          	eq_:    
 665: 3896+10	04AB  E1      	    pop hl
 666: 3906+10	04AC  D1      	    pop de
 667: 3916+4	04AD  B7      	    or a               ; reset the carry flag
 668: 3920+15	04AE  ED52    	    sbc hl,de          ; only equality sets hl=0 here
 669: 3935+10	04B0  CAE203  	    jp z,true_
 670: 3945+10	04B3  C3DD03  	    jp false_
 671:				
 672:     -	04B6          	gt_:    
 673: 3955+10	04B6  E1      	    pop hl
 674: 3965+10	04B7  D1      	    pop de
 675: 3975+12	04B8  1802    	    jr lt1_
 676:				    
 677:     -	04BA          	lt_:    
 678: 3987+10	04BA  D1      	    pop de
 679: 3997+10	04BB  E1      	    pop hl
 680:				    
 681:     -	04BC          	lt1_:   
 682: 4007+4	04BC  B7      	    or a                ; reset the carry flag
 683: 4011+15	04BD  ED52    	    sbc hl,de           ; only equality sets hl=0 here
 684: 4026+10	04BF  DAE203  	    jp c,true_
 685: 4036+10	04C2  C3DD03  	    jp false_
 686:				    
 687:     -	04C5          	grave_:                         
 688:     -	04C5          	str:                                                      
 689: 4046+6	04C5  03      	    inc bc
 690:				    
 691:     -	04C6          	str1:            
 692: 4052+7	04C6  0A      	    ld a, (bc)
 693: 4059+6	04C7  03      	    inc bc
 694: 4065+7	04C8  FE60    	    cp "`"                      ; ` is the string terminator
 695: 4072+7+5	04CA  2805    	    jr Z,str2
 696: 4079+17	04CC  CD8500  	    call putchar
 697: 4096+12	04CF  18F5    	    jr str1
 698:     -	04D1          	str2:  
 699: 4108+6	04D1  0B      	    dec bc
 700: 4114+8	04D2  FDE9    	    jp   (IY) 
 701:				
 702:     -	04D4          	lbrack_:
 703:     -	04D4          	arrDef:                         
 704: 4122+10	04D4  210000  	    ld hl,0
 705: 4132+11	04D7  39      	    add hl,sp                   ; save 
 706: 4143+17	04D8  CDA203  	    call rpush
 707: 4160+8	04DB  FDE9    	    jp (iy)
 708:				
 709:     -	04DD          	num_:   
 710: 4168+10	04DD  C33E07  	    jp num
 711:     -	04E0          	rparen_: 
 712: 4178+10	04E0  C3C405  	    jp again		            ; close loop
 713:     -	04E3          	rbrack_:
 714: 4188+10	04E3  C36E07  	    jp arrEnd
 715:     -	04E6          	colon_:   
 716: 4198+10	04E6  C31107  	    jp def
 717:     -	04E9          	lparen_: 
 718: 4208+10	04E9  C38A05  	    jp begin
 719:				    
 720:     -	04EC          	question_:
 721: 4218+12	04EC  1850    	    jr arrAccess
 722:     -	04EE          	hash_:
 723: 4230+12	04EE  185B    	    jr hex
 724:     -	04F0          	star_:   
 725: 4242+12	04F0  1878    	    jr mul      
 726:     -	04F2          	slash_:   
 727:				
 728:     -	04F2          	alt_:                           ; falls through (must be on page 4) 
 729:				;*******************************************************************
 730:				; Page 5 primitive routines 
 731:				;*******************************************************************
 732:     -	04F2          	alt:                                
 733: 4254+6	04F2  03      	    inc bc
 734: 4260+7	04F3  0A      	    ld a,(bc)
 735: 4267+7	04F4  FE7B    	    cp "z"+1
 736: 4274+7+5	04F6  300C    	    jr nc,alt1
 737: 4281+7	04F8  FE61    	    cp "a"
 738: 4288+7+5	04FA  300C    	    jr nc,altVar
 739: 4295+7	04FC  FE5B    	    cp "Z"+1
 740: 4302+7+5	04FE  3004    	    jr nc,alt1
 741: 4309+7	0500  FE41    	    cp "A"
 742: 4316+7+5	0502  302D    	    jr nc,altCode
 743:     -	0504          	alt1:
 744: 4323+6	0504  0B      	    dec bc
 745: 4329+10	0505  C3B707  	    jp div
 746:				
 747:     -	0508          	altVar:
 748: 4339+7	0508  FE69    	    cp "i"
 749: 4346+7	050A  2E00    	    ld l,0
 750: 4353+10	050C  CA1E05  	    jp z,loopVar
 751: 4363+7	050F  FE6A    	    cp "j"
 752: 4370+7	0511  2E08    	    ld l,8
 753: 4377+7+5	0513  2809    	    jr z,loopVar
 754: 4384+10	0515  216884  	    ld hl,altVars
 755: 4394+17	0518  CD3003  	    call lookupRef
 756: 4411+10	051B  C30C04  	    jp var1                    
 757:				
 758:     -	051E          	loopVar:    
 759: 4421+7	051E  2600    	    ld h,0
 760: 4428+8	0520  DD54    	    ld d,ixh
 761: 4436+8	0522  DD5D    	    ld e,ixl
 762: 4444+11	0524  19      	    add hl,de
 763: 4455+10	0525  C30C04  	    jp var1
 764:				
 765:     -	0528          	comment:
 766: 4465+6	0528  03      	    inc bc                      ; point to next char
 767: 4471+7	0529  0A      	    ld a,(bc)
 768: 4478+7	052A  FE0D    	    cp ASCII_CR                     ; terminate at cr 
 769: 4485+7+5	052C  20FA    	    jr NZ,comment
 770: 4492+6	052E  0B      	    dec bc
 771: 4498+8	052F  FDE9    	    jp   (IY) 
 772:				
 773:     -	0531          	altCode:
 774: 4506+10	0531  215E83  	    ld hl,altCodes
 775: 4516+7	0534  D641    	    sub "A"
 776: 4523+4	0536  85      	    add a,L
 777: 4527+4	0537  6F      	    ld L,A
 778: 4531+7	0538  7E      	    ld a,(hl)                   ;       get low jump address
 779: 4538+10	0539  210006  	    ld hl,page6
 780: 4548+4	053C  6F      	    ld L,A                      
 781: 4552+4	053D  E9      	    jp (hl)                     ;       Jump to routine
 782:				
 783:     -	053E          	arrAccess:
 784: 4556+10	053E  E1      	    pop hl                      ; hl = index  
 785: 4566+10	053F  D1      	    pop de                      ; de = array
 786: 4576+13	0540  3A6A84  	    ld a,(vByteMode)            ; a = data width
 787: 4589+4	0543  3C      	    inc a
 788: 4593+7+5	0544  2801    	    jr z,arrAccess1
 789: 4600+11	0546  29      	    add hl,hl                   ; if data width = 2 then double 
 790:     -	0547          	arrAccess1:
 791: 4611+11	0547  19      	    add hl,de                   ; hl = addr
 792: 4622+10	0548  C30C04  	    jp var1
 793:				
 794:     -	054B          	hex:
 795: 4632+10	054B  210000  	    ld hl,0	    		        ; Clear hl to accept the number
 796:     -	054E          	hex1:
 797: 4642+6	054E  03      	    inc bc
 798: 4648+7	054F  0A      	    ld a,(bc)		            ; Get the character which is a numeral
 799: 4655+8	0550  CB77    	    BIT 6,A                     ; is it uppercase alpha?
 800: 4663+10	0552  CA5705  	    jp Z, hex2                  ; no a decimal
 801: 4673+7	0555  D607    	    sub 7                       ; sub 7  to make $A - $F
 802:     -	0557          	hex2:
 803: 4680+7	0557  D630    	    sub $30                     ; Form decimal digit
 804: 4687+10	0559  DA6007  	    jp C,num2
 805: 4697+7	055C  FE10    	    cp $0F+1
 806: 4704+10	055E  D26007  	    jp NC,num2
 807: 4714+11	0561  29      	    add hl,hl                   ; 2X ; Multiply digit(s) in hl by 16
 808: 4725+11	0562  29      	    add hl,hl                   ; 4X
 809: 4736+11	0563  29      	    add hl,hl                   ; 8X
 810: 4747+11	0564  29      	    add hl,hl                   ; 16X     
 811: 4758+4	0565  85      	    add a,L                     ; add into bottom of hl
 812: 4762+4	0566  6F      	    ld  L,A                     
 813: 4766+10	0567  C34E05  	    jp  hex1
 814:				
 815:     -	056A          	mul:
 816: 4776+10	056A  D1      	    pop de                      ; de = 2nd arg
 817: 4786+10	056B  E1      	    pop hl                      ; hl = 1st arg
 818: 4796+11	056C  C5      	    push bc                     ; save IP
 819: 4807+4	056D  7D      	    ld a,l
 820: 4811+4	056E  4C      	    ld c,h
 821: 4815+7	056F  0610    	    ld b,16
 822: 4822+10	0571  210000  	    ld hl,0
 823:     -	0574          	mul1:
 824: 4832+11	0574  29      	    add hl,hl
 825: 4843+4	0575  17      	    rla
 826: 4847+8	0576  CB11    	    rl c
 827: 4855+7+5	0578  3007    	    jr nc,mul2
 828: 4862+11	057A  19      	    add hl,de
 829: 4873+7	057B  CE00    	    adc a,0
 830: 4880+10	057D  D28105  	    jp nc,mul2
 831: 4890+4	0580  0C      	    inc c
 832:     -	0581          	mul2:
 833: 4894+8+5	0581  10F1    	    djnz mul1
 834: 4902+4	0583  EB      	    ex de,hl                    ; de = lsw result
 835: 4906+4	0584  61      	    ld h,c
 836: 4910+4	0585  6F      	    ld l,a                      ; hl = msw result
 837: 4914+10	0586  C1      	    pop bc                      ; restore IP
 838: 4924+10	0587  C3F807  		jp divExit                  ; pushes lsw, puts msw in vRemain 
 839:				
 840:     -	058A          	begin:
 841:     -	058A          	loopStart:
 842: 4934+20	058A  ED430282	    ld (vTemp1),bc              ; save start
 843: 4954+7	058E  1E01    	    ld e,1                      ; skip to loop end, nesting = 1
 844:     -	0590          	loopStart1:
 845: 4961+6	0590  03      	    inc bc
 846: 4967+7	0591  0A      	    ld a,(bc)
 847: 4974+17	0592  CD5B03  	    call nesting                ; affects zero flag
 848: 4991+7+5	0595  20F9    	    jr nz,loopStart1
 849: 4998+10	0597  D1      	    pop de                      ; de = limit
 850: 5008+4	0598  7B      	    ld a,e                      ; is it zero?
 851: 5012+4	0599  B2      	    or d
 852: 5016+7+5	059A  2007    	    jr nz,loopStart2
 853: 5023+6	059C  1B      	    dec de                      ; de = TRUE
 854: 5029+20	059D  ED539E84	    ld (vElse),de
 855: 5049+12	05A1  181F    	    jr loopStart4               ; yes continue after skip    
 856:     -	05A3          	loopStart2:
 857: 5061+7	05A3  3E02    	    ld a,2                      ; is it TRUE
 858: 5068+4	05A5  83      	    add a,e
 859: 5072+4	05A6  82      	    add a,d
 860: 5076+7+5	05A7  2003    	    jr nz,loopStart3                
 861: 5083+10	05A9  110100  	    ld de,1                     ; yes make it 1
 862:     -	05AC          	loopStart3:    
 863: 5093+4	05AC  60      	    ld h,b
 864: 5097+4	05AD  69      	    ld l,c
 865: 5101+17	05AE  CDA203  	    call rpush                  ; rpush loop end
 866: 5118+6	05B1  0B      	    dec bc                      ; IP points to ")"
 867: 5124+16	05B2  2A0282  	    ld hl,(vTemp1)              ; restore start
 868: 5140+17	05B5  CDA203  	    call rpush                  ; rpush start
 869: 5157+4	05B8  EB      	    ex de,hl                    ; hl = limit
 870: 5161+17	05B9  CDA203  	    call rpush                  ; rpush limit
 871: 5178+10	05BC  21FFFF  	    ld hl,-1                    ; hl = count = -1 
 872: 5188+17	05BF  CDA203  	    call rpush                  ; rpush count
 873:     -	05C2          	loopstart4:    
 874: 5205+8	05C2  FDE9    	    jp (iy)
 875:				    
 876:     -	05C4          	again:
 877:     -	05C4          	loopEnd:    
 878: 5213+19	05C4  DD5E02  	    ld e,(ix+2)                 ; de = limit
 879: 5232+19	05C7  DD5603  	    ld d,(ix+3)
 880: 5251+4	05CA  7B      	    ld a,e                      ; a = low(limit)
 881: 5255+4	05CB  B2      	    or d                        ; if limit 0 exit loop
 882: 5259+7+5	05CC  282B    	    jr z,loopEnd4                  
 883: 5266+6	05CE  13      	    inc de                      ; is limit -2
 884: 5272+6	05CF  13      	    inc de
 885: 5278+4	05D0  7B      	    ld a,e                      ; a = low(limit)
 886: 5282+4	05D1  B2      	    or d                        ; if limit 0 exit loop
 887: 5286+7+5	05D2  2809    	    jr z,loopEnd2               ; yes, loop again
 888: 5293+6	05D4  1B      	    dec de
 889: 5299+6	05D5  1B      	    dec de
 890: 5305+6	05D6  1B      	    dec de
 891: 5311+19	05D7  DD7302  	    ld (ix+2),e                  
 892: 5330+19	05DA  DD7203  	    ld (ix+3),d
 893:     -	05DD          	loopEnd2:
 894: 5349+19	05DD  DD5E00  	    ld e,(ix+0)                 ; inc counter
 895: 5368+19	05E0  DD5601  	    ld d,(ix+1)
 896: 5387+6	05E3  13      	    inc de
 897: 5393+19	05E4  DD7300  	    ld (ix+0),e                  
 898: 5412+19	05E7  DD7201  	    ld (ix+1),d
 899:     -	05EA          	loopEnd3:
 900: 5431+10	05EA  110000  	    ld de,FALSE                 ; if clause ran then vElse = FALSE    
 901: 5441+20	05ED  ED539E84	    ld (vElse),de
 902: 5461+19	05F1  DD4E04  	    ld c,(ix+4)                 ; IP = start
 903: 5480+19	05F4  DD4605  	    ld b,(ix+5)
 904: 5499+8	05F7  FDE9    	    jp (iy)
 905:     -	05F9          	loopEnd4:    
 906: 5507+10	05F9  110800  	    ld de,2*4                   ; rpop frame
 907: 5517+15	05FC  DD19    	    add ix,de
 908: 5532+8	05FE  FDE9    	    jp (iy)
 909:				    
 910:				; **************************************************************************
 911:				; Page 6 Alt primitives
 912:				; **************************************************************************
 913:     -	0600          	    org $600 ; .align $100
 914:     -	0600          	page6:
 915:				
 916:				; allocates raw heap memory in bytes (ignores byte mode)
 917:				; n -- a
 918:     -	0600          	alloc_:
 919: 5540+10	0600  D1      	    pop de
 920: 5550+16	0601  2A7684  	    ld hl,(vHeapPtr)
 921: 5566+11	0604  E5      	    push hl
 922: 5577+11	0605  19      	    add hl,de
 923: 5588+16	0606  227684  	    ld (vHeapPtr),hl
 924:     -	0609          	aNop_:
 925: 5604+8	0609  FDE9    	    jp (iy)    
 926:				
 927:				; returns the size of an array
 928:				; a -- n
 929:     -	060B          	arrSize_:
 930:     -	060B          	arrSize:
 931: 5612+10	060B  E1      	    pop hl
 932: 5622+6	060C  2B      	    dec hl                      ; msb size 
 933: 5628+7	060D  56      	    ld d,(hl)
 934: 5635+6	060E  2B      	    dec hl                      ; lsb size 
 935: 5641+7	060F  5E      	    ld e,(hl)
 936: 5648+11	0610  D5      	    push de
 937: 5659+8	0611  FDE9    	    jp (iy)
 938:				
 939:     -	0613          	break_:
 940:     -	0613          	while_:
 941:     -	0613          	while:
 942: 5667+10	0613  E1      	    pop hl
 943: 5677+4	0614  7D      	    ld a,l
 944: 5681+4	0615  B4      	    or h
 945: 5685+7+5	0616  2009    	    jr nz,while2
 946: 5692+19	0618  DD4E06  	    ld c,(ix+6)                 ; IP = )
 947: 5711+19	061B  DD4607  	    ld b,(ix+7)
 948: 5730+10	061E  C3F905  	    jp loopEnd4
 949:     -	0621          	while2:
 950: 5740+8	0621  FDE9    	    jp (iy)
 951:				
 952:     -	0623          	depth_:
 953:     -	0623          	depth:
 954: 5748+10	0623  210000  	    ld hl,0
 955: 5758+11	0626  39      	    add hl,SP
 956: 5769+4	0627  EB      	    EX de,hl
 957: 5773+10	0628  210082  	    ld hl,DSTACK
 958: 5783+4	062B  B7      	    or A
 959: 5787+15	062C  ED52    	    sbc hl,de
 960: 5802+10	062E  C38C04  	    jp shr1
 961:				
 962:     -	0631          	falsex_:
 963: 5812+10	0631  C3DD03  	    jp false_
 964:				
 965:     -	0634          	printChar_:
 966: 5822+10	0634  E1      	    pop hl
 967: 5832+4	0635  7D      	    ld a,L
 968: 5836+17	0636  CD8500  	    call putchar
 969: 5853+8	0639  FDE9    	    jp (iy)
 970:				
 971:     -	063B          	else_:
 972: 5861+16	063B  2A9E84  	    ld hl,(vElse)
 973:     -	063E          	else1:
 974: 5877+11	063E  E5      	    push hl
 975: 5888+8	063F  FDE9    	    jp (iy)
 976:				
 977:     -	0641          	exec_:
 978: 5896+17	0641  CD4606  	    call exec1
 979: 5913+8	0644  FDE9    	    jp (iy)
 980:     -	0646          	exec1:
 981: 5921+10	0646  E1      	    pop hl
 982: 5931+19	0647  E3      	    EX (SP),hl
 983: 5950+4	0648  E9      	    jp (hl)
 984:				
 985:     -	0649          	editDef_:
 986: 5954+17	0649  CD9906  	    call editDef
 987: 5971+8	064C  FDE9    	    jp (iy)
 988:				
 989:     -	064E          	prompt_:
 990: 5979+17	064E  CD8203  	    call prompt
 991: 5996+8	0651  FDE9    	    jp (iy)
 992:				
 993:     -	0653          	go_:				    
 994: 6004+10	0653  D1      	    pop de
 995:     -	0654          	go1:
 996: 6014+4	0654  7A      	    ld a,D                      ; skip if destination address is null
 997: 6018+4	0655  B3      	    or E
 998: 6022+7+5	0656  280E    	    jr Z,go3
 999: 6029+4	0658  60      	    ld h,b
1000: 6033+4	0659  69      	    ld l,c
1001: 6037+6	065A  03      	    inc bc                      ; read next char from source
1002: 6043+7	065B  0A      	    ld a,(bc)                   ; if ; to tail call optimise
1003: 6050+7	065C  FE3B    	    cp ";"                      ; by jumping to rather than calling destination
1004: 6057+7+5	065E  2803    	    jr Z,go2
1005: 6064+17	0660  CDA203  	    call rpush                  ; save Instruction Pointer
1006:     -	0663          	go2:
1007: 6081+4	0663  42      	    ld b,d
1008: 6085+4	0664  4B      	    ld c,e
1009: 6089+6	0665  0B      	    dec bc
1010:     -	0666          	go3:
1011: 6095+8	0666  FDE9    	    jp (iy)                     
1012:				
1013:     -	0668          	key_:
1014: 6103+17	0668  CD8100  	    call getchar
1015: 6120+7	066B  2600    	    ld H,0
1016: 6127+4	066D  6F      	    ld L,A
1017: 6131+12	066E  18CE    	    jr else1
1018:				
1019:     -	0670          	inPort_:			    
1020: 6143+10	0670  E1      	    pop hl
1021: 6153+4	0671  79      	    ld a,C
1022: 6157+4	0672  4D      	    ld C,L
1023: 6161+12	0673  ED68    	    IN L,(C)
1024: 6173+7	0675  2600    	    ld H,0
1025: 6180+4	0677  4F      	    ld C,A
1026: 6184+12	0678  18C4    	    jr else1
1027:				
1028:     -	067A          	newln_:
1029: 6196+17	067A  CD8B03  	    call crlf
1030: 6213+8	067D  FDE9    	    jp (iy)        
1031:				
1032:     -	067F          	outPort_:
1033: 6221+10	067F  E1      	    pop hl
1034: 6231+4	0680  59      	    ld E,C
1035: 6235+4	0681  4D      	    ld C,L
1036: 6239+10	0682  E1      	    pop hl
1037: 6249+12	0683  ED69    	    OUT (C),L
1038: 6261+4	0685  4B      	    ld C,E
1039: 6265+8	0686  FDE9    	    jp (iy)        
1040:				
1041:     -	0688          	truex_:
1042: 6273+10	0688  C3E203  	    jp true_
1043:				
1044:     -	068B          	unlimit_:
1045: 6283+10	068B  21FEFF  	    ld hl,-2
1046: 6293+12	068E  18AE    	    jr else1
1047:				
1048:     -	0690          	varAccess_:
1049: 6305+10	0690  219C84  	    ld hl,vPointer
1050: 6315+7	0693  5E      	    ld e,(hl)
1051: 6322+6	0694  23      	    inc hl
1052: 6328+7	0695  56      	    ld d,(hl)
1053: 6335+11	0696  D5      	    push de
1054: 6346+8	0697  FDE9    	    jp (iy)
1055:				
1056:				;*******************************************************************
1057:				; Subroutines
1058:				;*******************************************************************
1059:				
1060:     -	0699          	editDef:                        ; lookup up def based on number
1061: 6354+10	0699  E1      	    pop hl                      ; pop ret address
1062: 6364+19	069A  E3      	    EX (SP),hl                  ; swap with TOS                  
1063: 6383+4	069B  7D      	    ld a,L
1064: 6387+4	069C  08      	    EX AF,AF'
1065: 6391+4	069D  7D      	    ld a,l
1066: 6395+17	069E  CD2903  	    call lookupRef0
1067: 6412+7	06A1  5E      	    ld E,(hl)
1068: 6419+6	06A2  23      	    inc hl
1069: 6425+7	06A3  56      	    ld D,(hl)
1070: 6432+4	06A4  7A      	    ld a,D
1071: 6436+4	06A5  B3      	    or E
1072: 6440+10	06A6  210080  	    ld hl,TIB
1073: 6450+7+5	06A9  2814    	    jr Z,editDef3
1074: 6457+7	06AB  3E3A    	    ld a,":"
1075: 6464+17	06AD  CDB803  	    call writeChar
1076: 6481+4	06B0  08      	    EX AF,AF'
1077: 6485+17	06B1  CDB803  	    call writeChar
1078: 6502+12	06B4  1801    	    jr editDef2
1079:     -	06B6          	editDef1:
1080: 6514+6	06B6  13      	    inc de
1081:     -	06B7          	editDef2:        
1082: 6520+7	06B7  1A      	    ld a,(de)
1083: 6527+17	06B8  CDB803  	    call writeChar
1084: 6544+7	06BB  FE3B    	    cp ";"
1085: 6551+7+5	06BD  20F7    	    jr NZ,editDef1
1086:     -	06BF          	editDef3:        
1087: 6558+10	06BF  110080  	    ld de,TIB
1088: 6568+4	06C2  B7      	    or A
1089: 6572+15	06C3  ED52    	    sbc hl,de
1090: 6587+16	06C5  227C84  	    ld (vTIBPtr),hl
1091: 6603+10	06C8  C9      	    ret
1092:				
1093:				; hl = value
1094:     -	06C9          	printDec:    
1095: 6613+8	06C9  CB7C    	    bit 7,h
1096: 6621+7+5	06CB  280B    	    jr z,printDec2
1097: 6628+7	06CD  3E2D    	    ld a,'-'
1098: 6635+17	06CF  CD8500  	    call putchar
1099: 6652+4	06D2  AF      	    xor a  
1100: 6656+4	06D3  95      	    sub l  
1101: 6660+4	06D4  6F      	    ld l,a
1102: 6664+4	06D5  9F      	    sbc a,a  
1103: 6668+4	06D6  94      	    sub h  
1104: 6672+4	06D7  67      	    ld h,a
1105:     -	06D8          	printDec2:        
1106: 6676+11	06D8  C5      	    push bc
1107: 6687+7	06D9  0E00    	    ld c,0                      ; leading zeros flag = false
1108: 6694+10	06DB  11F0D8  	    ld de,-10000
1109: 6704+17	06DE  CDFA06  	    call printDec4
1110: 6721+10	06E1  1118FC  	    ld de,-1000
1111: 6731+17	06E4  CDFA06  	    call printDec4
1112: 6748+10	06E7  119CFF  	    ld de,-100
1113: 6758+17	06EA  CDFA06  	    call printDec4
1114: 6775+7	06ED  1EF6    	    ld e,-10
1115: 6782+17	06EF  CDFA06  	    call printDec4
1116: 6799+4	06F2  0C      	    inc c                       ; flag = true for at least digit
1117: 6803+7	06F3  1EFF    	    ld e,-1
1118: 6810+17	06F5  CDFA06  	    call printDec4
1119: 6827+10	06F8  C1      	    pop bc
1120: 6837+10	06F9  C9      	    ret
1121:     -	06FA          	printDec4:
1122: 6847+7	06FA  062F    	    ld b,'0'-1
1123:     -	06FC          	printDec5:	    
1124: 6854+4	06FC  04      	    inc b
1125: 6858+11	06FD  19      	    add hl,de
1126: 6869+7+5	06FE  38FC    	    jr c,printDec5
1127: 6876+15	0700  ED52    	    sbc hl,de
1128: 6891+7	0702  3E30    	    ld a,'0'
1129: 6898+4	0704  B8      	    cp b
1130: 6902+7+5	0705  2005    	    jr nz,printDec6
1131: 6909+4	0707  AF      	    xor a
1132: 6913+4	0708  B1      	    or c
1133: 6917+5+6	0709  C8      	    ret z
1134: 6922+12	070A  1801    	    jr printDec7
1135:     -	070C          	printDec6:	    
1136: 6934+4	070C  0C      	    inc c
1137:     -	070D          	printDec7:	    
1138: 6938+4	070D  78      	    ld a,b
1139: 6942+10	070E  C38500  	    jp putchar
1140:				
1141:				;*******************************************************************
1142:				; Page 5 primitive routines continued
1143:				;*******************************************************************
1144:				
1145:     -	0711          	def:                            ; Create a colon definition
1146: 6952+6	0711  03      	    inc bc
1147: 6958+7	0712  0A      	    ld  a,(bc)                  ; Get the next character
1148: 6965+7	0713  FE40    	    cp "@"                      ; is it anonymous
1149: 6972+7+5	0715  2008    	    jr nz,def0
1150: 6979+6	0717  03      	    inc bc
1151: 6985+20	0718  ED5B7684	    ld de,(vHeapPtr)            ; return start of definition
1152: 7005+11	071C  D5      	    push de
1153: 7016+12	071D  180E    	    jr def1
1154:     -	071F          	def0:    
1155: 7028+13	071F  329A84  	    ld (vLastDef),a
1156: 7041+17	0722  CD2903  	    call lookupRef0
1157: 7058+20	0725  ED5B7684	    ld de,(vHeapPtr)            ; start of defintion
1158: 7078+7	0729  73      	    ld (hl),E                   ; Save low byte of address in CFA
1159: 7085+6	072A  23      	    inc hl              
1160: 7091+7	072B  72      	    ld (hl),D                   ; Save high byte of address in CFA+1
1161: 7098+6	072C  03      	    inc bc
1162:     -	072D          	def1:                               ; Skip to end of definition   
1163: 7104+7	072D  0A      	    ld a,(bc)                   ; Get the next character
1164: 7111+6	072E  03      	    inc bc                      ; Point to next character
1165: 7117+7	072F  12      	    ld (de),A
1166: 7124+6	0730  13      	    inc de
1167: 7130+7	0731  FE3B    	    cp ";"                      ; Is it a semicolon 
1168: 7137+7+5	0733  2802    	    jr Z, def2                  ; end the definition
1169: 7144+12	0735  18F6    	    jr  def1                    ; get the next element
1170:     -	0737          	def2:    
1171: 7156+6	0737  0B      	    dec bc
1172:     -	0738          	def3:
1173: 7162+20	0738  ED537684	    ld (vHeapPtr),de            ; bump heap ptr to after definiton
1174: 7182+8	073C  FDE9    	    jp (iy)       
1175:				
1176:     -	073E          	num:
1177: 7190+10	073E  210000  		ld hl,$0000				    ; Clear hl to accept the number
1178: 7200+7	0741  0A      		ld a,(bc)				    ; Get numeral or -
1179: 7207+7	0742  FE2D    	    cp '-'
1180: 7214+7+5	0744  2001    	    jr nz,num0
1181: 7221+6	0746  03      	    inc bc                      ; move to next char, no flags affected
1182:     -	0747          	num0:
1183: 7227+4	0747  08      	    ex af,af'                   ; save zero flag = 0 for later
1184:     -	0748          	num1:
1185: 7231+7	0748  0A      	    ld a,(bc)                   ; read digit    
1186: 7238+7	0749  D630    	    sub "0"                     ; less than 0?
1187: 7245+7+5	074B  3813    	    jr c, num2                  ; not a digit, exit loop 
1188: 7252+7	074D  FE0A    	    cp 10                       ; greater that 9?
1189: 7259+7+5	074F  300F    	    jr nc, num2                 ; not a digit, exit loop
1190: 7266+6	0751  03      	    inc bc                      ; inc IP
1191: 7272+4	0752  54      	    ld d,h                    ; multiply hl * 10
1192: 7276+4	0753  5D      	    ld e,l                    ; multiply hl * 10
1193: 7280+11	0754  29      	    add hl,hl    
1194: 7291+11	0755  29      	    add hl,hl    
1195: 7302+11	0756  19      	    add hl,de    
1196: 7313+11	0757  29      	    add hl,hl    
1197: 7324+4	0758  85      	    add a,l                     ; add digit in a to hl
1198: 7328+4	0759  6F      	    ld l,a
1199: 7332+7	075A  3E00    	    ld a,0
1200: 7339+4	075C  8C      	    adc a,h
1201: 7343+4	075D  67      	    ld h,a
1202: 7347+12	075E  18E8    	    jr num1 
1203:     -	0760          	num2:
1204: 7359+6	0760  0B      	    dec bc
1205: 7365+4	0761  08      	    ex af,af'                   ; restore zero flag
1206: 7369+7+5	0762  2007    	    jr nz, num3
1207: 7376+4	0764  EB      	    ex de,hl                    ; negate the value of hl
1208: 7380+10	0765  210000  	    ld hl,0
1209: 7390+4	0768  B7      	    or a                        ; jump to sub2
1210: 7394+15	0769  ED52    	    sbc hl,de    
1211:     -	076B          	num3:
1212: 7409+11	076B  E5      	    push hl                     ; Put the number on the stack
1213: 7420+8	076C  FDE9    	    jp (iy)                     ; and process the next character
1214:				
1215:     -	076E          	arrEnd:                       
1216: 7428+20	076E  ED430282	    ld (vTemp1),bc              ; save IP
1217: 7448+17	0772  CDAD03  	    call rpop
1218: 7465+16	0775  220482  	    ld (vTemp2),hl              ; save old SP
1219: 7481+4	0778  54      	    ld d,h                    ; de = hl = old SP
1220: 7485+4	0779  5D      	    ld e,l                    ; de = hl = old SP
1221: 7489+4	077A  B7      	    or a 
1222: 7493+15	077B  ED72    	    sbc hl,sp                   ; hl = array count (items on stack)
1223: 7508+8	077D  CB3C    	    srl h                       ; num items = num bytes / 2
1224: 7516+8	077F  CB1D    	    rr l                        
1225: 7524+4	0781  44      	    ld b,h                    ; bc = count
1226: 7528+4	0782  4D      	    ld c,l                    ; bc = count
1227: 7532+16	0783  2A7684  	    ld hl,(vHeapPtr)            ; hl = array[-4]
1228: 7548+7	0786  71      	    ld (hl),c                   ; write num items in length word
1229: 7555+6	0787  23      	    inc hl
1230: 7561+7	0788  70      	    ld (hl),b
1231: 7568+6	0789  23      	    inc hl                      ; hl = array[0], bc = count
1232:				                                ; de = old SP, hl = array[0], bc = count
1233: 7574+12	078A  1811    	    jr arrayEnd2
1234:     -	078C          	arrayEnd1:                        
1235: 7586+6	078C  0B      	    dec bc                      ; dec items count
1236: 7592+6	078D  1B      	    dec de
1237: 7598+6	078E  1B      	    dec de
1238: 7604+7	078F  1A      	    ld a,(de)                   ; a = lsb of stack item
1239: 7611+7	0790  77      	    ld (hl),a                   ; write lsb of array item
1240: 7618+6	0791  23      	    inc hl                      ; move to msb of array item
1241: 7624+13	0792  3A6A84  	    ld a,(vByteMode)            ; vByteMode=1? 
1242: 7637+4	0795  3C      	    inc a
1243: 7641+7+5	0796  2805    	    jr z,arrayEnd2
1244: 7648+6	0798  13      	    inc de
1245: 7654+7	0799  1A      	    ld a,(de)                   ; a = msb of stack item
1246: 7661+6	079A  1B      	    dec de
1247: 7667+7	079B  77      	    ld (hl),a                   ; write msb of array item
1248: 7674+6	079C  23      	    inc hl                      ; move to next word in array
1249:     -	079D          	arrayEnd2:
1250: 7680+4	079D  79      	    ld a,c                      ; if not zero loop
1251: 7684+4	079E  B0      	    or b
1252: 7688+7+5	079F  20EB    	    jr nz,arrayEnd1
1253: 7695+4	07A1  EB      	    ex de,hl                    ; de = end of array 
1254: 7699+16	07A2  2A0482  	    ld hl,(vTemp2)
1255: 7715+6	07A5  F9      	    ld sp,hl                    ; SP = old SP
1256: 7721+16	07A6  2A7684  	    ld hl,(vHeapPtr)            ; de = array[-2]
1257: 7737+6	07A9  23      	    inc hl
1258: 7743+6	07AA  23      	    inc hl
1259: 7749+11	07AB  E5      	    push hl                     ; return array[0]
1260: 7760+20	07AC  ED537684	    ld (vHeapPtr),de            ; move heap* to end of array
1261: 7780+20	07B0  ED4B0282	    ld bc,(vTemp1)              ; restore IP
1262: 7800+10	07B4  C3D403  	    jp resetByteMode
1263:				
1264:     -	07B7          	div:
1265: 7810+4	07B7  60      	    ld h,b
1266: 7814+4	07B8  69      	    ld l,c                    ; hl = IP
1267: 7818+10	07B9  C1      	    pop bc                      ; bc = denominator
1268: 7828+19	07BA  E3      	    ex (sp),hl                  ; save IP, hl = numerator  
1269: 7847+4	07BB  7C      	    ld a,h
1270: 7851+4	07BC  A8      	    xor b
1271: 7855+11	07BD  F5      	    push af
1272: 7866+4	07BE  A8      	    xor b
1273: 7870+10	07BF  F2C807  	    jp p,absbc
1274:				;absHL
1275: 7880+4	07C2  AF      	    xor a  
1276: 7884+4	07C3  95      	    sub l  
1277: 7888+4	07C4  6F      	    ld l,a
1278: 7892+4	07C5  9F      	    sbc a,a  
1279: 7896+4	07C6  94      	    sub h  
1280: 7900+4	07C7  67      	    ld h,a
1281:     -	07C8          	absbc:
1282: 7904+4	07C8  A8      	    xor b
1283: 7908+10	07C9  F2D207  	    jp p,$+9
1284: 7918+4	07CC  AF      	    xor a  
1285: 7922+4	07CD  91      	    sub c  
1286: 7926+4	07CE  4F      	    ld c,a
1287: 7930+4	07CF  9F      	    sbc a,a  
1288: 7934+4	07D0  90      	    sub b  
1289: 7938+4	07D1  47      	    ld b,a
1290: 7942+11	07D2  29      	    add hl,hl
1291: 7953+7	07D3  3E0F    	    ld a,15
1292: 7960+10	07D5  110000  	    ld de,0
1293: 7970+4	07D8  EB      	    ex de,hl
1294: 7974+12	07D9  1804    	    jr jumpin
1295:     -	07DB          	Loop1:
1296: 7986+11	07DB  09      	    add hl,bc   ;--
1297:     -	07DC          	Loop2:
1298: 7997+4	07DC  3D      	    dec a       ;4
1299: 8001+7+5	07DD  280E    	    jr z,EndSDiv ;12|7
1300:     -	07DF          	jumpin:
1301: 8008+8	07DF  CB23    	    sla e       ;8
1302: 8016+8	07E1  CB12    	    rl d        ;8
1303: 8024+15	07E3  ED6A    	    adc hl,hl   ;15
1304: 8039+15	07E5  ED42    	    sbc hl,bc   ;15
1305: 8054+7+5	07E7  38F2    	    jr c,Loop1  ;23-2b
1306: 8061+4	07E9  1C      	    inc e       ;--
1307: 8065+10	07EA  C3DC07  	    jp Loop2    ;--
1308:     -	07ED          	EndSDiv:
1309: 8075+10	07ED  F1      	    pop af  
1310: 8085+10	07EE  F2F707  	    jp p,div10
1311: 8095+4	07F1  AF      	    xor a  
1312: 8099+4	07F2  93      	    sub e  
1313: 8103+4	07F3  5F      	    ld e,a
1314: 8107+4	07F4  9F      	    sbc a,a  
1315: 8111+4	07F5  92      	    sub d  
1316: 8115+4	07F6  57      	    ld d,a
1317:     -	07F7          	div10:
1318: 8119+10	07F7  C1      	    pop bc
1319:     -	07F8          	divExit:
1320: 8129+11	07F8  D5      	    push de                     ; quotient
1321: 8140+16	07F9  228A84  	    ld (vRemain),hl             ; remainder
1322: 8156+8	07FC  FDE9    	    jp (iy)
1323:				
1324:				; *******************************************************************************
1325:				; *********  END OF MAIN   ******************************************************
1326:				; *******************************************************************************
1327:				; *******************************************************************************
**** BeanZee.z80 ****
   8:				.include "ram.asm"
**** ram.asm ****
   1:     -	0080          	DSIZE       EQU $80
   2:     -	0080          	RSIZE       EQU $80
   3:     -	0100          	TIBSIZE     EQU $100		; 256 bytes , along line!
   4:     -	0034          	VARS_SIZE   equ 26*2
   5:				
   6:     -	8000          	    .ORG RAMSTART
   7:				
   8:     -	8000          	TIB:        DS TIBSIZE
   9:				
  10:     -	8100          	            DS RSIZE
  11:     -	8180          	rStack:        
  12:				
  13:     -	8180          	            DS DSIZE
  14:     -	8200          	dStack:        
  15:     -	8200          	stack:
  16:     -	8200          	tbPtr:      DS 2                ; reserved for tests
  17:     -	8202          	vTemp1:     ds 2                ; 
  18:     -	8204          	vTemp2:     ds 2                ; 
  19:				
  20:     -	8206          	RST08:      DS 2                 
  21:     -	8208          	RST10:      DS 2                 
  22:     -	820A          	RST18:      DS 2                 
  23:     -	820C          	RST20:      DS 2                 
  24:     -	820E          	RST28:      DS 2                 
  25:     -	8210          	RST30:      DS 2                ; 
  26:     -	8212          	BAUD        DS 2                ; 
  27:     -	8214          	INTVEC:     DS 2                ; 
  28:     -	8216          	NMIVEC:     DS 2                ; 
  29:     -	8218          	GETCVEC:    DS 2                ;   
  30:     -	821A          	PUTCVEC:    DS 2                ;   
  31:				
  32:     -	8300          	            org $8300 ; .align $100
  33:     -	8300          	opcodes:    
  34:     -	8300          	            DS $80-32-1-1
  35:     -	835E          	altCodes:
  36:     -	835E          	            DS 26
  37:				
  38:     -	8400          	            org $8400 ; .align $100
  39:				
  40:     -	8400          	vars:       DS VARS_SIZE
  41:     -	8434          	defs:       DS VARS_SIZE
  42:				
  43:     -	8468          	altVars:
  44:     -	8468          	            DS 2                ; a
  45:     -	846A          	vByteMode:  DS 2                ; b
  46:     -	846C          	vCarry:     DS 2                ; c carry variable
  47:     -	846E          	            DS 2                ; d
  48:     -	8470          	            DS 2                ; e
  49:     -	8472          	vIntFunc:   DS 2                ; f interrupt func
  50:     -	8474          	            DS 2                ; g
  51:     -	8476          	vHeapPtr:   DS 2                ; h heap pointer variable
  52:     -	8478          	            DS 2                ; i loop variable
  53:     -	847A          	            DS 2                ; j outer loop variable
  54:     -	847C          	vTIBPtr:    DS 2                ; k address of text input buffer
  55:     -	847E          	            DS 2                ; l  
  56:     -	8480          	            DS 2                ; m  
  57:     -	8482          	            DS 2                ; n 
  58:     -	8484          	            DS 2                ; o
  59:     -	8486          	            DS 2                ; p
  60:     -	8488          	            DS 2                ; q
  61:     -	848A          	vRemain:    DS 2                ; r remainder of last division     
  62:     -	848C          	vStkStart:  DS 2                ; s address of start of stack
  63:     -	848E          	            DS 2                ; t
  64:     -	8490          	            DS 2                ; u
  65:     -	8492          	vIntID:     DS 2                ; v interrupt id
  66:     -	8494          	            DS 2                ; w
  67:     -	8496          	            DS 2                ; x     
  68:     -	8498          	            DS 2                ; y
  69:     -	849A          	vLastDef:   DS 2                ; z name of last defined function
  70:				
  71:     -	849C          	vPointer:   DS 2                ; 
  72:     -	849E          	vElse:      DS 2                ; 
  73:				
  74:     -	84A0          	HEAP:         
**** BeanZee.z80 ****



Statistics:

     4	passes
     0	jr promotions
   281	symbols
  1803	bytes

     9	macro calls
    73	macro bytes
     0	invented symbols



Symbol Table:

ASCII_BS       =08        8
ASCII_CR       =0D        13
ASCII_NL       =0A        10
BAUD            8212      33298
BEANZEE        =01        1
BITBANG        =00        0
BITIM1          58        88
BITIME          53        83
BSLASH         =5C        92
CR             =0D        13
CTRL_C         =03        3
CTRL_E         =05        5
CTRL_H         =08        8
CTRL_L         =0C        12
CTRL_R         =12        18
CTRL_S         =13        19
DSIZE          =80        128
DSTACK          8200      33280
ESC            =1B        27
EXTENDED       =00        0
EndSDiv          7ED      2029
FALSE          =00        0
GETCVEC         8218      33304
HEAP            84A0      33952
INTVEC          8214      33300
ISR             8B        139
IntRet          5F        95
LF             =0A        10
LOADER         =00        0
Loop1            7DB      2011
Loop2            7DC      2012
NEXT             2B4      692
NMIVEC          8216      33302
PUTCVEC         821A      33306
PWRUP           50        80
RAMSTART       =8000      32768
RC2014         =00        0
RESET           96        150
ROMSTART       =00        0
RSIZE          =80        128
RST08           8206      33286
RST10           8208      33288
RST18           820A      33290
RST20           820C      33292
RST28           820E      33294
RST30           8210      33296
RSTACK          8180      33152
RSTVEC          00        0
RXDATA          78        120
RxChar          78        120
TEC_1          =00        0
TIB             8000      32768
TIBSIZE        = 100      256
TRUE           =FFFFFFFF  -1
TXDATA          6B        107
TxChar          6B        107
TxChar1         6D        109
UNLIMITED      =FFFFFFFF  -1
USB_DATA       =01        1
USB_STATUS     =00        0
VARS_SIZE      =34        52
aNop_            609      1545
absbc            7C8      1992
again            5C4      1476
alloc_           600      1536
alt              4F2      1266
alt1             504      1284
altCode          531      1329
altCodes        835E      33630
altVar           508      1288
altVars         8468      33896
alt_             4F2      1266
amper_           42D      1069
and1             434      1076
and2             435      1077
arrAccess        53E      1342
arrAccess1       547      1351
arrDef           4D4      1236
arrEnd           76E      1902
arrSize          60B      1547
arrSize_         60B      1547
arrayEnd1        78C      1932
arrayEnd2        79D      1949
assign           41D      1053
assign1          42B      1067
assignByteMode   3D5      981
at_              401      1025
backSpace        20A      522
bang_            41D      1053
begin            58A      1418
break_           613      1555
bslash_          403      1027
call_            456      1110
caret_           441      1089
carry            3C6      966
colon_           4E6      1254
comma_           46B      1131
comment          528      1320
crlf             38B      907
def              711      1809
def0             71F      1823
def1             72D      1837
def2             737      1847
def3             738      1848
defs            8434      33844
depth            623      1571
depth_           623      1571
div              7B7      1975
div10            7F7      2039
divExit          7F8      2040
dollar_          492      1170
dot2             464      1124
dot_             460      1120
dquote_          471      1137
editDef          699      1689
editDef1         6B6      1718
editDef2         6B7      1719
editDef3         6BF      1727
editDef_         649      1609
edit_            185      389
else1            63E      1598
else_            63B      1595
enter            3BD      957
eq_              4AB      1195
etx              2D2      722
etx1             2DB      731
exec1            646      1606
exec_            641      1601
exit             2C8      712
false_           3DD      989
falsex_          631      1585
getchar         81        129
go1              654      1620
go2              663      1635
go3              666      1638
go_              653      1619
grave_           4C5      1221
gt_              4B6      1206
hash_            4EE      1262
hex              54B      1355
hex1             54E      1358
hex2             557      1367
iAltCodes        1EE      494
iOpcodes         1C4      452
inPort_          670      1648
init             2DE      734
initOps          305      773
initOps1         30E      782
initOps2         31E      798
initOps2a        323      803
interpret        22B      555
interpret2       235      565
interpret3       23D      573
interpret4       243      579
invert           44A      1098
jumpin           7DF      2015
key_             668      1640
lbrace_          487      1159
lbrack_          4D4      1236
list_            190      400
lookupRef        330      816
lookupRef0       329      809
lookupRef1       332      818
loopEnd          5C4      1476
loopEnd2         5DD      1501
loopEnd3         5EA      1514
loopEnd4         5F9      1529
loopStart        58A      1418
loopStart1       590      1424
loopStart2       5A3      1443
loopStart3       5AC      1452
loopStart4       5C2      1474
loopVar          51E      1310
lparen_          4E9      1257
lt1_             4BC      1212
lt_              4BA      1210
macro            277      631
macros           180      384
minus_           496      1174
mul              56A      1386
mul1             574      1396
mul2             581      1409
nesting          35B      859
nesting1         364      868
nesting2         373      883
nesting3         375      885
nesting4         380      896
newln_           67A      1658
num              73E      1854
num0             747      1863
num1             748      1864
num2             760      1888
num3             76B      1899
num_             4DD      1245
opcodes         8300      33536
outPort_         67F      1663
page4            400      1024
page6            600      1536
percent_         479      1145
pipe_            438      1080
plus_            44F      1103
printChar_       634      1588
printDec         6C9      1737
printDec2        6D8      1752
printDec4        6FA      1786
printDec5        6FC      1788
printDec6        70C      1804
printDec7        70D      1805
printStack_      1A9      425
printStr         392      914
printhex         33C      828
printhex2        347      839
printhex3        350      848
prompt           382      898
prompt_          64E      1614
putStr           39D      925
putStr0          399      921
putchar         85        133
question_        4EC      1260
quote_           400      1024
rbrace_          48B      1163
rbrack_          4E3      1251
reedit_          180      384
resetByteMode    3D4      980
rparen_          4E0      1248
rpop             3AD      941
rpop2            3B7      951
rpush            3A2      930
rst1            03        3
rst2            0D        13
rst3            15        21
rst4            1D        29
rst5            25        37
rst6            2D        45
semi_            480      1152
setByteMode      3D0      976
sevensegment    40        64
shr1             48C      1164
slash_           4F2      1266
stack           8200      33280
star_            4F0      1264
start            218      536
str              4C5      1221
str1             4C6      1222
str2             4D1      1233
sub1             4A2      1186
sub2             4A4      1188
tbPtr           8200      33280
tilde_           44A      1098
true1            3E5      997
true_            3E2      994
truex_           688      1672
underscore_      401      1025
unlimit_         68B      1675
vByteMode       846A      33898
vCarry          846C      33900
vElse           849E      33950
vHeapPtr        8476      33910
vIntFunc        8472      33906
vIntID          8492      33938
vLastDef        849A      33946
vPointer        849C      33948
vRemain         848A      33930
vStkStart       848C      33932
vTIBPtr         847C      33916
vTemp1          8202      33282
vTemp2          8204      33284
var1             40C      1036
var2             41A      1050
varAccess_       690      1680
var_             405      1029
vars            8400      33792
waitchar         248      584
waitchar1        288      648
waitchar3        296      662
waitchar4        2AC      684
while            613      1555
while2           621      1569
while_           613      1555
writeChar        3B8      952
xor1             442      1090
